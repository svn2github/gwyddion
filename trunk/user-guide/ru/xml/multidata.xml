<?xml version="1.0" encoding="utf-8"?>
<!-- @(#) $Id: multidata.xml 15257 2013-09-01 20:02:51Z yeti-dn $ -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<sect1 xmlns:xi="http://www.w3.org/2001/XInclude" id="multidata">
  <title>Множественные данные</title>
  <sect2 id="data-arithmetic">
    <title>Арифметические операции</title>
    <indexterm><primary>арифметика над данными</primary></indexterm>
    <para>
      <menuchoice>
        <guimenu>Обработка данных</guimenu>
        <guisubmenu>Множественные данные</guisubmenu>
        <guimenuitem>Арифметические операции</guimenuitem>
      </menuchoice>
    </para>
    <para>Модуль арифметики над данными позволяет проводить произвольные операции над точками отдельного поля данных или соответствующими точками нескольких полей данных (на текущий момент до восьми). И, хотя это не является его главным предназначением, он может использоваться как калькулятор с непосредственным расчётом выражений. Синтаксис выражений описан в разделе <link linkend="expression-syntax">Выражения</link>.</para>
    <para>Выражение может содержать следующие переменные, соответствующие значениям отдельных полей данных:</para>
    <para>
      <informaltable frame="none" id="table-arithmetic-variables">
        <tgroup cols="2">
          <?dblatex lX?>
          <thead>
            <row>
              <entry>Переменная</entry>
              <entry>Описание</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><varname>d1</varname>, …, <varname>d8</varname></entry>
              <entry>Значение данных в точке. Значение записывается в основных физических единицах, например, для высоты в 233 нм, значение <varname>d1</varname> равно 2.33e-7.</entry>
            </row>
            <row>
              <entry><varname>m1</varname>, …, <varname>m8</varname></entry>
              <entry>Значение маски в точке. Значение маски равно либо 0 (для немаскированных точек) либо 1 (для точек под маской). Переменные маски могут использоваться и если маска не задана, значение равно 0 во всех точках в этом случае.</entry>
            </row>
            <row>
              <entry><varname>bx1</varname>, …, <varname>bx8</varname></entry>
              <entry>Производная по горизонтали в точке. Снова значение в физических единицах. Производная считается как стандартная симметричная производная, кроме точек на границе, где берётся производная только с одной стороны.</entry>
            </row>
            <row>
              <entry><varname>by1</varname>, …, <varname>by8</varname></entry>
              <entry>Производная по вертикали в точке, определяется так же, как и производная по горизонтали.</entry>
            </row>
            <row>
              <entry><varname>x</varname></entry>
              <entry>Горизонтальная координата точки (в физических единицах). Одинакова во всех полях из-за требования совместимости (см. ниже).</entry>
            </row>
            <row>
              <entry><varname>y</varname></entry>
              <entry>Вертикальная координата точки (в физических единицах). Одинакова во всех полях из-за требования совместимости (см. ниже).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </para>
    <para>В дополнение определяется константа <xi:include href="eqi-pi.xml"/>, которую можно набирать либо как <xi:include href="eqi-pi.xml"/>, либо как <userinput>pi</userinput>.</para>
    <para>Поля данных, которые реально используются в выражении должны быть совместимы. Это означает, что их размеры (как физические, так и в пикселях) должны быть идентичны. Другие поля данных (те, что не входят в выражения) ни на что не влияют. Результат всегда помещается в созданное заново поле данных в текущем открытом файле (который может отличаться от файлов, содержащих все операнды).</para>
    <para>Поскольку модуль расчёта не может автоматически вывести правильные физические единицы измерения результата, единицы должны быть явно указаны. Это можно сделать двумя путями: или выбрав поле данных с теми же единицами значений, что должны быть у результата, или выбрав опцию <guilabel>Задать единицы</guilabel> и введя единицы вручную.</para>
    <para>Следующая таблица содержит несколько простых примеров выражений:</para>
    <para>
      <informaltable frame="none" id="table-arithmetic-examples">
        <tgroup cols="2">
          <?dblatex lX?>
          <thead>
            <row>
              <entry>Выражение</entry>
              <entry>Значение</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><userinput>-d1</userinput></entry>
              <entry>Инвертирует значение. Результат очень похож на Инвертировать значение, за исключением того, что последнее инвертирует значения относительно среднего в то время, как здесь мы просто меняем знак у значений,</entry>
            </row>
            <row>
              <entry><userinput>(d1 - d2)^2</userinput></entry>
              <entry>Квадрат разницы между двумя полями данных.</entry>
            </row>
            <row>
              <entry><userinput>d1 + m1*1e-8</userinput></entry>
              <entry>Модификация значений под маской. Конкретно в этом случае значение 10<superscript>-8</superscript> добавилось ко всем точкам под маской.</entry>
            </row>
            <row>
              <entry><userinput>d1*m3 + d2*(1-m3)</userinput></entry>
              <entry>Комбинация двух полей данных. Точки берутся либо из поля 1, либо из 2, в соответствии с маской, заданной на поле 3.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </para>
    <para>В режиме калькулятора выражение вычисляется сразу по мере его ввода и результат показывается под полем ввода выражения. Не требуется совершать специальных действий чтобы переключаться между выражениями над полями данных и калькулятором: выражения, содержащие только численные величины рассчитываются сразу, выражения, содержащие поля данных используются чтобы рассчитать новое поле данных. Изображение предпросмотра, показывающее результат операции с полями не обновляется сразу следом за набором выражения; его можно обновить или нажатием на кнопку <guibutton>Обновить</guibutton> или нажатием <keycap>Enter</keycap> в поле ввода выражения.</para>
  </sect2>
  <sect2 id="immerse">
    <title>Встраивание фрагмента</title>
    <indexterm><primary>встраивание фрагмента</primary></indexterm>
    <para>
      <menuchoice>
        <guimenu>Обработка данных</guimenu>
        <guisubmenu>Множественные данные</guisubmenu>
        <guimenuitem>Встроить</guimenuitem>
      </menuchoice>
    </para>
    <para>Встраивание вставляет фрагмент, изображение с более высоким разрешением, внутрь более крупного изображения. Изображение, на котором была запущена функция формирует большое, базовое изображение.</para>
    <para>Положение фрагмента может быть задано вручную на большом изображении с помощью мыши. Кнопка <guibutton>Уточнить</guibutton> может быть затем использована для получения точных координат в окрестности текущей позиции, которые дают максимум корреляции между фрагментом и большим изображением. Или наиболее подходящее положение может быть найдено на всём изображении с помощью кнопки <guibutton>Найти</guibutton>.</para>
    <para>Следует отметить, что корреляционный поиск не чувствителен к масштабу значений и смещений, следовательно, автоматический поиск соответствия основан исключительно на свойствах данных, абсолютные значения высоты не играют значения.</para>
    <para><guilabel>Разрешение результата</guilabel> контролирует размер и разрешение результирующего изображения:</para>
    <variablelist>
      <varlistentry>
        <term>
          <guilabel>Увеличить разрешение большого изображения</guilabel>
        </term>
        <listitem>Разрешение результата определяется разрешением встраиваемого фрагмента. Следовательно, масштаб большого изображения увеличивается.</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Снизить разрешение фрагмента</guilabel>
        </term>
        <listitem>Разрешение результата определяется разрешением большого изображения. Масштаб фрагмента уменьшается. </listitem>
      </varlistentry>
    </variablelist>
    <para><guilabel>Выравнивание фрагмента</guilabel> выбирает преобразование значений <xi:include href="eqi-z.xml"/> фрагмента:</para>
    <variablelist>
      <varlistentry>
        <term>
          <guilabel>Нет</guilabel>
        </term>
        <listitem>Подстройка значений <xi:include href="eqi-z.xml"/> не производится.</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Среднее значение</guilabel>
        </term>
        <listitem>Все значения изображения фрагмента сдвигаются на постоянную величину чтобы его среднее значение соответствовало среднему значению соответствующей области большого изображения.</listitem>
      </varlistentry>
    </variablelist>
  </sect2>
  <sect2 id="merge">
    <title>Объединение</title>
    <indexterm><primary>объединение изображений</primary></indexterm>
    <indexterm><primary>соединение изображений</primary></indexterm>
    <para>
      <menuchoice>
        <guimenu>Обработка данных</guimenu>
        <guisubmenu>Множественные данные</guisubmenu>
        <guimenuitem>Объединить</guimenuitem>
      </menuchoice>
    </para>
    <para>Изображения, которые формируют части большего изображения, могут быть объединены вместе с помощью команды "Объединить."  Изображение, на котором была запущена эта функция формирует базовое изображение, изображение, выбранное с помощью <guilabel>Объединить с</guilabel>, представляет второй операнд. Сторона базового изображения к которой будет присоединено второе управляется с помощью выпадающего меню <guilabel>Поместить второй операнд</guilabel>.</para>
    <para>Если изображения идеально соответствуют друг другу они могут просто совмещены сторонами без подстройки. Этот вариант выбирается опцией <guilabel>Нет</guilabel> в управляющем выравниванием элементе <guilabel>Выровнять второй операнд</guilabel>. </para>
    <para>Однако, обычно необходима подстройка. Опция <guilabel>Корреляция</guilabel> выбирает автоматическое выравнивание основанным на корреляции поиском наилучшего соответствия. Поиск производится как вдоль направления параллельного присоединяемой стороне, так и в перпендикулярном ему. Если присутствует параллельный сдвиг, результат расширяется таким образом, чтобы в него полностью поместились оба изображения (неопределённые значения заполняются значением фона).</para>
    <para>Опция <guilabel>Режим границы</guilabel> полезна только в последнем случае неточно выровненных изображений. Она управляет тем, что будет с пересекающейся частью обоих изображений:</para>
    <variablelist>
      <varlistentry>
        <term>
          <guilabel>Первый операнд</guilabel>
        </term>
        <listitem>Значения в пересекающихся областях берутся из первого, базового изображения.</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Второй операнд</guilabel>
        </term>
        <listitem>Значения в пересекающихся областях берутся из второго изображения.</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Сгладить</guilabel>
        </term>
        <listitem>Гладкий переход между первым и вторым изображением производится на пересекающейся области используя взвешенное среднее с подходящей функцией веса.</listitem>
      </varlistentry>
    </variablelist>
  </sect2>
  <sect2 id="mutual-crop">
    <title>Взаимное кадрирование</title>
    <indexterm><primary>взаимное кадрирование двух изображений</primary></indexterm>
    <indexterm><primary>удаление непересекающихся областей</primary></indexterm>
    <para>
      <menuchoice>
        <guimenu>Обработка данных</guimenu>
        <guisubmenu>Множественные данные</guisubmenu>
        <guimenuitem>Взаимное кадрирование</guimenuitem>
      </menuchoice>
    </para>
    <para>С помощью этого модуля можно кадрировать два слегка сдвинутых друг относительно друга изображения одной и той же области (например, до и после какого-то воздействия), или, другими словами, обрезать непересекающиеся части возле границы изображений.</para>
    <para>Общая область определяется корреляцией большего изображения с центральной частью меньшего. Разрешения обоих изображений (количество точек на единицу длины) должны быть одинаковы. </para>
    <para>На текущий момент единственным параметром сейчас является <guilabel>Второй операнд</guilabel> - будет посчитана корреляция между ним и текущим активным изображением и оба поля данных будут обрезаны чтобы удалить непересекающиеся области возле границы.</para>
  </sect2>
  <sect2 id="cross-correlation">
    <title>Взаимная корреляция</title>
    <indexterm><primary>взаимная корреляция</primary></indexterm>
    <para>
      <menuchoice>
        <guimenu>Обработка данных</guimenu>
        <guisubmenu>Множественные данные</guisubmenu>
        <guimenuitem>Взаимная корреляция</guimenuitem>
      </menuchoice>
    </para>
    <para>Модуль находит локальные корреляции между фрагментами двух различных изображений. В идеальном случае выводится сдвиг каждого пикселя первого изображения как показано на втором. Это можно использовать для определения локальных изменений на поверхности, которую сняли дважды (сдвиг может существовать, например, при какой-то деформации образца или неправильной работе микроскопа).</para>
    <para>Для каждого пикселя первого операнда (текущего окна) модуль берёт его окрестность и ищет наилучшую корреляцию с вторым операндом внутри заданной области. Положение максимума корреляции используется для задания значения сдвига для вышеупомянутого пикселя первого операнда.</para>
    <variablelist>
      <varlistentry>
        <term>
          <guilabel>Второй операнд</guilabel>
        </term>
        <listitem>Изображение, которое будет использоваться для сравнения с первым операндом - базовое изображение.</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Размер поиска</guilabel>
        </term>
        <listitem>Используется для задания области, где алгоритм будет искать локальную окрестность (на втором операнде). Должно быть больше, чем размер окна. Необходимо увеличить размер, если между сравниваемыми изображениями есть большие различия.</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Размер окна</guilabel>
        </term>
        <listitem>Используется для задания размера области локальной окрестности (на первом операнде). Должно быть меньше, чем размер поиска. Увеличение этого значения может улучшить работу модуля, но, разумеется, замедлит расчёт.</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Тип вывода</guilabel>
        </term>
        <listitem>Определяет выходной формат (пиксельного сдвига).</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Добавить маску порога низкой степени корреляции.</guilabel>
        </term>
        <listitem>Для некоторых пикселей (с не очень ярко выраженной окрестностью) степень корреляции будет низкой везде, но алгоритм всё равно будет выбирать некоторые максимальные значения этой степени. Чтобы увидеть эти точки и возможно убрать их из дальнейшего рассмотрения можно дать модулю установить маску сдвигов пикселей с низкой степенью корреляции, для которых вероятность того, что она определена правильно, невелика.</listitem>
      </varlistentry>
    </variablelist>
  </sect2>
  <sect2 id="mask-by-correlation">
    <title>Пометить корреляцией</title>
    <indexterm><primary>поиск корреляцией</primary></indexterm>
    <para>
      <menuchoice>
        <guimenu>Обработка данных</guimenu>
        <guisubmenu>Множественные данные</guisubmenu>
        <guimenuitem>Пометить корреляцией</guimenuitem>
      </menuchoice>
    </para>
    <para>Модуль ищет заданный шаблон корреляции внутри текущего изображения. Результирующее положение шаблона помечается маской в окне данных.</para>
    <variablelist>
      <varlistentry>
        <term>
          <guilabel>Ядро корреляции</guilabel>
        </term>
        <listitem>Изображение, которое нужно найти в базовом.</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Тип вывода</guilabel>
        </term>
        <listitem>Есть несколько вариантов того. что выводить: локальные максимумы корреляции (отдельные точки), маски с размером ядра для каждого максимума корреляции (хорошо подходят для презентаций) или просто степень корреляции.</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Метод корреляции</guilabel>
        </term>
        <listitem>Здесь можно выбрать алгоритм расчёта корреляции.</listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <guilabel>Порог</guilabel>
        </term>
        <listitem>Порог для определения, будет ли локальный максимум считаться <quote>ядром корреляции, найденным в этом месте</quote>.</listitem>
      </varlistentry>
    </variablelist>
  </sect2>
  <sect2 id="neural-network">
    <title>Обработка нейросетью</title>
    <indexterm><primary>нейросеть</primary></indexterm>
    <para>Обработку с помощью нейросети можно использовать для расчёта одного типа данных из другого даже если формула или соотношение, описывающие связь между ними, не описаны в явном виде. Соотношение непосредственно встраивается в нейросеть на этапе, называемом обучением, который задействует пары известных входных и выходных данных, обычно называемых модель и сигнал. В этом процессе сеть оптимизируется таким образом, чтобы воспроизводить настолько точно, насколько это возможно сигнал из модели. Обученная нейросеть затем может быть использована для обработки данных модели, для которых выходной сигнал не известен и получать, обычно несколько приближенно, как сигнал должен выглядеть. Другим возможным применением может быть аппроксимация методов обработки данных, которые являются точными, но требующими значительного времени. В этом случае сигналом будут выходные данные точного метода, и нейросеть обучается воспроизводить их.</para>
    <para>Поскольку обучение нейросети и её применение это два совершенно различных шага, они реализованы в Gwyddion как две разные функции.</para>
    <sect3 id="neural-network-training">
      <title>Обучение</title>
      <indexterm>
        <primary>нейросеть</primary>
        <secondary>обучение</secondary>
      </indexterm>
      <para>
        <menuchoice>
          <guimenu>Обработка данных</guimenu>
          <guisubmenu>Множественные данные</guisubmenu>
          <guimenuitem>Обучение Нейросети</guimenuitem>
        </menuchoice>
      </para>
      <para>Основные функции, которые контролируют процесс обучения, содержатся во вкладке <guilabel>Обучение</guilabel>: <variablelist>
          <varlistentry>
            <term><guilabel>Модель</guilabel></term>
            <listitem>Данные модели, т.е. входные данные для обучения. Для обучения можно выбрать несколько моделей последовательно (с соответствующими сигналами).</listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>Сигнал</guilabel></term>
            <listitem>Данные сигнала для обучения, т.е. выходные данные, которые должна выдавать обученная нейросеть. Поле данных сигнала должно быть совместимо с полем модели, т.е. иметь одинаковые размеры в пикселях и физические.</listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>Шагов тренировки</guilabel></term>
            <listitem>Число шагов обучения, которое будет выполнено при нажатии <guibutton>Обучение</guibutton>. Каждый шаг состоит из одного прохода по всем данным сигнала. Можно установить число шагов обучения равным нулю, при этом обучения не будет производиться, но модель будет рассчитана нейросетью, и можно будет наблюдать результат расчёта.</listitem>
          </varlistentry>
          <varlistentry>
            <term><guibutton>Обучение</guibutton></term>
            <listitem>Начинает обучение. Это сравнительно медленный процесс, особенно при больших размерах поля данных и окна.</listitem>
          </varlistentry>
          <varlistentry>
            <term><guibutton>Переинициализация</guibutton></term>
            <listitem>Заново инициализирует нейросеть в необученном состоянии. Точнее, это означает, что веса нейронов устанавливаются в случайные значения.</listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>Режим использования маски</guilabel></term>
            <listitem>Можно обучать нейросеть только на подмножестве сигнала, заданным маской на данных сигнала (использование маски на модели будет бессмысленным из-за размеров окна).</listitem>
          </varlistentry>
        </variablelist></para>
      <para>Параметры нейросети можно изменить на вкладке <guilabel>Параметры</guilabel>. Изменение как размеров окна, так и числа скрытых узлов означает переинициализацию неросети (как при нажатии кнопки <guibutton>Переинициализировать</guibutton>). <variablelist>
          <varlistentry>
            <term><guilabel>Ширина окна</guilabel></term>
            <listitem>Горизонтальный размер окна. Входные данные для сети состоят из области вокруг пикселя модели, называемой окном. Окно центрируется на пикселе, поэтому предпочтительными являются нечётные размеры.</listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>Высота окна</guilabel></term>
            <listitem>Вертикальный размер окна.</listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>Скрытые узлы</guilabel></term>
            <listitem>Число узлов в <quote>скрытые</quote> слое нейросети. Большее число узлов приводит к более универсальной сети, с другой стороны стороны, оно приводит к замедлению обучения и применения нейросети. Обычно это число является малым по сравнению с числом пикселей окна.</listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>Степень XY источника</guilabel></term>
            <listitem>Степень, с которой единицы измерения пространственных размеров модели должны появляться в сигнале. Используется только при применении нейросети к данным.</listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>Степень Z источника</guilabel></term>
            <listitem>Степень, с которой единицы измерения <quote>высоты</quote> модели должны появляться в сигнале. Используется только при применении нейросети к данным.</listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>Заданные единицы</guilabel></term>
            <listitem>Фиксированные единицы измерения результата. Они комбинируются с другими параметрами единиц измерения, поэтому если вы хотите получить единицы измерения результата независимыми от входных, необходимо установить обе степени в ноль. Используются только при применении нейросети к данным.</listitem>
          </varlistentry>
        </variablelist></para>
      <para>Обученную нейросеть можно сохранить. загрузить для переобучения на других данных и т.п. Управление списком сетей похоже на <link linkend="raw-file-import">предустановки загрузки сырых данных</link>.</para>
      <para>В дополнение к сетям в списке, существует ещё одна неназванная сеть, и это та сеть, которая обучается в текущий момент. Когда вы загружаете сеть, обучаемая сеть становится копией загруженной. Обучение затем не меняет именованные сети; чтобы сохранить сеть после обучения (под уже имеющимся или новым именем) необходимо явно использовать кнопку <guibutton>Сохранить</guibutton>.</para>
    </sect3>
    <sect3>
      <title>Применение</title>
      <indexterm>
        <primary>нейросеть</primary>
        <secondary>применение</secondary>
      </indexterm>
      <para>
        <menuchoice>
          <guimenu>Обработка данных</guimenu>
          <guisubmenu>Множественные данные</guisubmenu>
          <guimenuitem>Применить нейросеть</guimenuitem>
        </menuchoice>
      </para>
      <para>Применить обученную нейросеть просто: нужно выбрать одну из списка и нажать  <guibutton>OK</guibutton>. Неименнованная сеть, которая обучается в настоящии момент также присутствует в списке под названием <quote>Обучается</quote>.</para>
      <para>Поскольку нейросети обрабатывают и производят нормализованные данные, они не сохраняют хорошо соотношения сторон, особенно если масштаб модели, использованной при обучении, сильно отличается от масштаба реальных входных данных. Если выходные данные должны масштабироваться вместе со входными, необходимо включить опцию <guilabel>Масштабировать пропорционально входным данным</guilabel>, которая масштабирует выходные данные пропорционально обратному отношению диапазонов текущих данных и данных, использованных при обучении.</para>
    </sect3>
  </sect2>
</sect1>
<!-- vim: set ts=2 sw=2 et : -->
