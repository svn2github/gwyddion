/*
 *  Copyright (C) 2008 Jan Horak
 *  E-mail: xhorak@gmail.com
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA 02110-1301, USA.
 *
 *  Description: This file contains overriden functions which cannot be
 *  automatically generated by  pygwy-codegen.
 */
/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#include <Python.h>
#include <pygobject.h>
#include <pygtk/pygtk.h>
#include <libprocess/gwyprocess.h>
#include <libgwyddion/gwyddion.h>
#include <libprocess/cdline.h>
#include <libprocess/hough.h>
#include <libprocess/tip.h>
#include <libgwymodule/gwymodule.h>
#include <libgwymodule/gwymodule-process.h>
#include <libdraw/gwygradient.h>
#include <libdraw/gwyglmaterial.h>
#include <libdraw/gwypixfield.h>
#include <libdraw/gwydraw.h>
#include <libgwydgets/gwy3dlabel.h>
#include <libgwydgets/gwy3dsetup.h>
#include <libgwydgets/gwy3dview.h>
#include <libgwydgets/gwy3dwindow.h>
#include <libgwydgets/gwyaxisdialog.h>
#include <libgwydgets/gwyaxis.h>
#include <libgwydgets/gwycoloraxis.h>
#include <libgwydgets/gwycolorbutton.h>
#include <libgwydgets/gwycombobox.h>
#include <libgwydgets/gwycurve.h>
#include <libgwydgets/gwydataview.h>
#include <libgwydgets/gwydataviewlayer.h>
#include <libgwydgets/gwydatawindow.h>
#include <libgwydgets/gwydgetenums.h>
#include <libgwydgets/gwydgetmarshals.h>
#include <libgwydgets/gwydgets.h>
#include <libgwydgets/gwydgettypes.h>
#include <libgwydgets/gwydgetutils.h>
#include <libgwydgets/gwygraphareadialog.h>
#include <libgwydgets/gwygrapharea.h>
#include <libgwydgets/gwygraphbasics.h>
#include <libgwydgets/gwygraphcorner.h>
#include <libgwydgets/gwygraphcurvemodel.h>
#include <libgwydgets/gwygraphcurves.h>
#include <libgwydgets/gwygraphdata.h>
#include <libgwydgets/gwygraph.h>
#include <libgwydgets/gwygraphlabeldialog.h>
#include <libgwydgets/gwygraphlabel.h>
#include <libgwydgets/gwygraphmodel.h>
#include <libgwydgets/gwygraphselections.h>
#include <libgwydgets/gwygraphwindow.h>
#include <libgwydgets/gwygraphwindowmeasuredialog.h>
#include <libgwydgets/gwyhmarkerbox.h>
#include <libgwydgets/gwyhruler.h>
#include <libgwydgets/gwyinventorystore.h>
#include <libgwydgets/gwylayer-basic.h>
#include <libgwydgets/gwylayer-mask.h>
#include <libgwydgets/gwymarkerbox.h>
#include <libgwydgets/gwynullstore.h>
#include <libgwydgets/gwyoptionmenus.h>
#include <libgwydgets/gwypixmaplayer.h>
#include <libgwydgets/gwyradiobuttons.h>
#include <libgwydgets/gwyruler.h>
#include <libgwydgets/gwyscitext.h>
#include <libgwydgets/gwyselectiongraph1darea.h>
#include <libgwydgets/gwyselectiongrapharea.h>
#include <libgwydgets/gwyselectiongraphline.h>
#include <libgwydgets/gwyselectiongraphpoint.h>
#include <libgwydgets/gwyselectiongraphzoom.h>
#include <libgwydgets/gwysensitivitygroup.h>
#include <libgwydgets/gwyshader.h>
#include <libgwydgets/gwystatusbar.h>
#include <libgwydgets/gwystock.h>
#include <libgwydgets/gwyvectorlayer.h>
#include <libgwydgets/gwyvruler.h>
#include <app/gwymoduleutils-file.h>
#include <app/gwymoduleutils.h>

typedef gdouble ArrayOfGDoubleNullTerminated;
typedef gint GIntValue;
typedef gdouble GDoubleValue;
typedef gdouble GDoubleArray;
typedef gdouble GDoubleArrayToFill;
typedef gchar keep_gchar;       // do not delete when returning
typedef gchar pass_owner_gchar; // do not delete in wrapped function

// ##include "pywrap.h"
%%
modulename gwy
%%
import gobject.GObject as PyGObject_Type
import gtk.Table as PyGtkTable_Type
import gtk.Widget as PyGtkWidget_Type
import gtk.Dialog as PyGtkDialog_Type
import gtk.Button as PyGtkButton_Type
import gtk.DrawingArea as PyGtkDrawingArea_Type
import gtk.Object as PyGtkObject_Type
import gtk.Window as PyGtkWindow_Type
import gtk.Layout as PyGtkLayout_Type
import gtk.TreeView as PyGtkTreeView_Type
import gtk.VBox as PyGtkVBox_Type
import gtk.Statusbar as PyGtkStatusbar_Type
import gtk.ComboBox as PyGtkComboBox_Type
import gtk.Tooltips as PyGtkTooltips_Type
import gtk.Orientation as PyGtkOrientation_Type
import gtk.PositionType as PyGtkPositionType_Type
import gtk.TreeIter as PyGtkTreeIter_Type
import gtk.ListStore as PyGtkListStore_Type
import gtk.UpdateType as PyGtkUpdateType_Type
import gtk.gdk.Drawable as PyGdkDrawable_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gtk.gdk.GC as PyGdkGC_Type
import gtk.gdk.LineStyle as PyGdkLineStyle_Type
%%
ignore-glob
  *_get_type
  gwy_container_gis_*
  gwy_container_get_string
  gwy_container_get_value_by_name
  gwy_container_set_value_by_name
  gwy_gradient_sample
  gwy_vector_layer_button*
  gwy_vector_layer_motion_notify
  gwy_vector_layer_key*
  gwy_md5_get_digest
  gwy_graph_draw_line
  gwy_gradient_get_samples
  gwy_data_field_get_data
  gwy_data_line_get_data
  gwy_container_set_string
  gwy_math_median
  gwy_math_sort
%%
ignore-type
  GwyPlainTool
%%
define gwy_app_data_browser_get_current kwargs
/**
 *  gwy_app_data_browser_get_current:
 *  @obj_type: object type, expected values: C{B{APP_DATA_FIELD_ID, APP_GRAPH_MODEL_ID,
 *  APP_SPECTRA_ID, APP_DATA_FIELD_KEY, APP_MASK_FIELD_KEY, APP_SHOW_FIELD_KEY,
 *  APP_GRAPH_MODEL_KEY, APP_SPECTRA_KEY, APP_CONTAINER, APP_DATA_VIEW, APP_GRAPH,
 *  APP_DATA_FIELD, APP_MASK_FIELD, APP_SHOW_FIELD, APP_GRAPH_MODEL, APP_SPECTRA}}
 *
 *  Get current object of given type.
 *
 *  Returns: reference to current object or None.
**/
static PyObject *
_wrap_gwy_app_data_browser_get_current(PyObject *self, PyObject *args, PyObject *kwargs)
{
   static char *kwlist[] = {"obj_type", NULL};
   GObject *gobj;
   PyObject *py_obj_type = NULL;
   GwyAppWhat obj_type;
   gint iobj;
   GQuark qobj;

   if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:gwy_app_data_browser_get_current", kwlist, &py_obj_type))
       return NULL;
   if (pyg_enum_get_value(GWY_TYPE_APP_WHAT, py_obj_type, (gpointer)&obj_type))
       return NULL;
   switch (obj_type) {
      case GWY_APP_DATA_FIELD_ID:
      case GWY_APP_GRAPH_MODEL_ID:
      case GWY_APP_SPECTRA_ID:
         // integer
         gwy_app_data_browser_get_current(obj_type, &iobj, NULL);
         return PyInt_FromLong(iobj);
         break;
      case GWY_APP_DATA_FIELD_KEY:
      case GWY_APP_MASK_FIELD_KEY:
      case GWY_APP_SHOW_FIELD_KEY:
      case GWY_APP_GRAPH_MODEL_KEY:
      case GWY_APP_SPECTRA_KEY:
         // quark
         gwy_app_data_browser_get_current(obj_type, &qobj, NULL);
         return PyLong_FromLong(qobj);
         break;
      case GWY_APP_CONTAINER:
      case GWY_APP_DATA_VIEW:
      case GWY_APP_GRAPH:
      case GWY_APP_DATA_FIELD:
      case GWY_APP_MASK_FIELD:
      case GWY_APP_SHOW_FIELD:
      case GWY_APP_GRAPH_MODEL:
      case GWY_APP_SPECTRA:
         // gobject
         gwy_app_data_browser_get_current(obj_type, &gobj, NULL);
         return pygobject_new(gobj);
         break;
      default:
         PyErr_SetString(PyExc_NotImplementedError, "Cannot recognize object type for conversion.");
         return NULL;
         break;
   }
}

%%
define gwy_app_data_browser_get_containers noargs
/**
 *  gwy_app_data_browser_get_containers:
 *
 *  Get list of containers of current data browser.
 *
 *  Returns: list of containers L{Container} object
**/
static PyObject *
_wrap_gwy_app_data_browser_get_containers(PyGObject *self)
{
   PyObject *list = NULL;

   list = PyList_New(0);
   gwy_app_data_browser_foreach(pygwy_create_py_list_of_containers, (gpointer) list);
   return list;
}

%%
define GwyDataField.duplicate noargs
/**
 * gwy_data_field_duplicate:
 *
 * Duplicate datafield
 *
 * Returns: duplicated datafield
**/
static PyObject *
_wrap_gwy_data_field_duplicate(PyGObject *self)
{
   GwyDataField *ret;

   ret = gwy_data_field_duplicate(GWY_DATA_FIELD(self->obj));

   return pygobject_new((GObject *)ret);
}

%%
override gwy_app_undo_qcheckpointv kwargs
static PyObject *
_wrap_gwy_app_undo_qcheckpointv(PyObject *self, PyObject *args, PyObject *kwargs)
{
   static char *kwlist[] = {"container", "key", NULL};

   PyGObject *cont;
   GQuark key;

   if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:gwy_app_undo_qcheckpointv", kwlist, &PyGwyContainer_Type, &cont, &key))
        return NULL;
   gwy_app_undo_qcheckpointv(GWY_CONTAINER(cont->obj), 1, &key);
   Py_INCREF(Py_None);
   return Py_None;
}

%%
define GwyDataField.get_data noargs
/**
 * gwy_data_field_get_data:
 *
 * Create a tuple of data which the datafield contains. Content of the tuple is NOT reference to original datafield but its copy.
 *
 * Returns: tuple of raw numeric data from DataField
**/
static PyObject *
_wrap_gwy_data_field_get_data(PyGObject *self)
{
   gdouble *data;
   gint len, xres, yres;
   PyObject *tuple;
   int i;

   xres = gwy_data_field_get_xres(GWY_DATA_FIELD(self->obj));
   yres = gwy_data_field_get_yres(GWY_DATA_FIELD(self->obj));
   // Get size of data field
   len = xres * yres;
   // Create tuple by size of data field
   tuple = PyTuple_New(len);

   data = gwy_data_field_get_data(GWY_DATA_FIELD(self->obj));
   // fill tuple with data field values
   for (i = 0; i < len; i++) {
      /* get data read only, any changes to the tuple does not reflect on actual datafield */
      PyTuple_SetItem(tuple, i, PyFloat_FromDouble(data[i]));
   }

   return tuple;
}

%%
define GwyDataField.get_data_pointer noargs
/**
 * gwy_data_field_get_data_pointer:
 *
 * Get Pointer to data which the datafield contains.
 *
 * Returns: integer pointing to the raw data of the datafield
**/
static PyObject *
_wrap_gwy_data_field_get_data_pointer(PyGObject *self)
{
   gdouble* data;
   unsigned long ptr;

   data = gwy_data_field_get_data(GWY_DATA_FIELD(self->obj));
   ptr = (long)data;

   return PyLong_FromUnsignedLong(ptr);
}

%%
define GwyBrick.get_data_pointer noargs
/**
 * gwy_brick_get_data_pointer:
 *
 * Get Pointer to data which the brick contains.
 *
 * Returns: integer pointing to the raw data of the brick
**/
static PyObject *
_wrap_gwy_brick_get_data_pointer(PyGObject *self)
{
   gdouble* data;
   unsigned long ptr;

   data = gwy_brick_get_data(GWY_BRICK(self->obj));
   ptr = (long)data;

   return PyLong_FromUnsignedLong(ptr);
}

%%
define GwyDataLine.get_data noargs
static PyObject *
_wrap_gwy_data_line_get_data(PyGObject *self)
{
   gdouble *data;
   gint res;
   PyObject *tuple;
   int i;

   // Get size of data line
   res = gwy_data_line_get_res(GWY_DATA_LINE(self->obj));
   // Create tuple by size of data field
   tuple = PyTuple_New(res);

   data = gwy_data_line_get_data(GWY_DATA_LINE(self->obj));
   // fill tuple with data field values
   for (i = 0; i < res; i++) {
      /* get data read only, any changes to the tuple does not reflect on actual datafield */
      PyTuple_SetItem(tuple, i, PyFloat_FromDouble(data[i]));
   }

   return tuple;
}

%%
override-slot GwyContainer.tp_as_mapping
static Py_ssize_t _map_gwy_container_length(PyGObject *cont)
{
    return gwy_container_get_n_items(GWY_CONTAINER(cont->obj));
};

static PyObject * _map_gwy_container_subscript(PyGObject * cont, PyObject * key)
{
   gchar* name;
   PyGObject* ret;
   GValue val;

   if (!PyString_Check(key))
   {
        PyErr_SetString(PyExc_TypeError, "Expected key to be a string.");
	return NULL;
   }

   name = PyString_AsString(key);

   if (gwy_container_contains_by_name((GWY_CONTAINER(cont->obj)), name)) {
     val = gwy_container_get_value_by_name((GWY_CONTAINER(cont->obj)), name);
     ret = pyg_value_as_pyobject(&val,0);
     g_value_unset(&val);
     return ret;
   }

   PyErr_SetString(PyExc_KeyError,"Nothing stored here");
   return NULL;
};

static int _map_gwy_container_ass_subscript(PyGObject *cont, PyObject *key, PyObject *v){
   char* name;
   GValue val;
   GType g_type;
   PyObject* py_type;
   gwy_clear(&val,1);

   if (!PyString_Check(key))
   {
        PyErr_SetString(PyExc_TypeError, "Expected key to be a string.");
        return -1;
   }

   name = PyString_AsString(key);

   if(v!=NULL) {
     py_type = PyObject_Type(v);
     g_type = pyg_type_from_object(py_type);
     Py_DECREF(py_type);
     if(g_type==0)
     {
        return -1;
     };
     g_value_init(&val, G_TYPE_FUNDAMENTAL(g_type));
     pyg_value_from_pyobject(&val,v);
     gwy_container_set_value_by_name((GWY_CONTAINER(cont->obj)), name, &val, NULL);
     g_value_unset(&val);

     return 0;
   }
   else
   {
     gwy_container_remove_by_name((GWY_CONTAINER(cont->obj)), name);
   };

   return 0;
};

PyMappingMethods G_GNUC_INTERNAL _wrap_gwy_container_tp_as_mapping = {
  (lenfunc) _map_gwy_container_length,
  (binaryfunc) _map_gwy_container_subscript,
  (objobjargproc) _map_gwy_container_ass_subscript
};

%%
define GwyContainer.set_string kwargs
/**
 * gwy_container_set_string:
 * @key: an object key
 * @value: new string
 *
 * Set string for key to given value
 *
 **/
static PyObject *
_wrap_gwy_container_set_string(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", "value", NULL };
    int key, value_len;
    guchar *value;
    gchar *dup_value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"is#:GwyContainer.set_string", kwlist, &key, &value, &value_len))
        return NULL;

    dup_value = g_strndup(value, value_len);
    gwy_container_set_string(GWY_CONTAINER(self->obj), key, dup_value);

    Py_INCREF(Py_None);
    return Py_None;
}

%%
define GwyContainer.get_string kwargs
static PyObject *
_wrap_gwy_container_get_string(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    int key;
    const guchar *value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:GwyContainer.set_string", kwlist, &key))
        return NULL;

    value = gwy_container_get_string(GWY_CONTAINER(self->obj), key);
    if (value)
        return PyString_FromString(value);
    else
        return NULL;
}

%%
define GwyContainer.get_object kwargs
/**
 * gwy_container_get_object:
 * @key: key of object.
 *
 * Get object of given key from container.
 *
 * Returns: object of given key
**/
static PyObject *
_wrap_gwy_container_get_object(PyGObject *self, PyObject *args, PyObject *kwargs)
{
   static char *kwlist[] = {"key", NULL};
   gint key;
   gpointer obj;

   if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:gwy_container_get_object", kwlist, &key))
      return NULL;
   obj = gwy_container_get_object((GWY_CONTAINER(self->obj)), key);
   if (obj && (GWY_IS_DATA_FIELD(obj) || GWY_IS_DATA_LINE(obj) || GWY_IS_RESOURCE(obj) || GWY_IS_SI_UNIT(obj))) {
      return pygobject_new((GObject *)obj);
   } else {
      Py_INCREF(Py_None);
      return Py_None;
   }
}

%%
define GwyContainer.keys noargs
static PyObject *
_wrap_gwy_container_keys(PyGObject *self)
{
   gint i;
   GQuark *keys;
   PyObject *tuple;

   keys = gwy_container_keys(GWY_CONTAINER(self->obj));
   tuple = PyTuple_New(gwy_container_get_n_items(GWY_CONTAINER(self->obj)));
   if (!tuple)
      return NULL;
   // fill tuple with keys
   for (i = 0 ; i < gwy_container_get_n_items(GWY_CONTAINER(self->obj)); i++) {
      PyTuple_SetItem(tuple, i, PyInt_FromLong(keys[i]));
   }
   g_free(keys);
   return tuple;
}

%%
define GwyContainer.keys_by_name noargs
static PyObject *
_wrap_gwy_container_keys_by_name(PyGObject *self)
{
   gint i;
   const gchar **keys;
   PyObject *tuple;

   keys = gwy_container_keys_by_name(GWY_CONTAINER(self->obj));
   tuple = PyTuple_New(gwy_container_get_n_items(GWY_CONTAINER(self->obj)));
   if (!tuple)
      return NULL;
   // fill tuple with keys
   for (i = 0 ; i < gwy_container_get_n_items(GWY_CONTAINER(self->obj)); i++) {
      PyTuple_SetItem(tuple, i, PyString_FromString(keys[i]));
   }
   g_free(keys);
   return tuple;
}

%%
define GwyContainer.get_value_by_name kwargs

static PyObject *
_wrap_gwy_container_get_value_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
   static char *kwlist[] = {"name", NULL};
   char* name;
   GValue val;
   PyObject* obj;

   if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:gwy.Container.get_value_by_name", kwlist, &name))
      return NULL;
   val = gwy_container_get_value_by_name((GWY_CONTAINER(self->obj)), name);

   obj = pyg_value_as_pyobject(&val,0);

   return obj;
}

%%
define GwyContainer.set_value_by_name kwargs

static PyObject *
_wrap_gwy_container_set_value_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
   static char *kwlist[] = {"name", "value", NULL};
   char* name;
   GValue val;
   PyObject* v;
   GType g_type;
   PyObject* py_type;
   gwy_clear(&val,1);

   if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO:gwy.Container.get_value_by_name", kwlist, &name, &v))
      return NULL;

   py_type = PyObject_Type(v);
   g_type = pyg_type_from_object(py_type);
   Py_DECREF(py_type);
   if(g_type==0)
   {
      return NULL;
   };
   g_value_init(&val, G_TYPE_FUNDAMENTAL(g_type));
   pyg_value_from_pyobject(&val,v);
   gwy_container_set_value_by_name((GWY_CONTAINER(self->obj)), name, &val, NULL);

   Py_RETURN_NONE;

};

%%
override gwy_app_file_load kwargs
/**
 * gwy_app_file_load:
 * @filename: Filename of file to open
 *
 * Load specified file
 *
 * Returns: A main GwyContainer of opened file
**/
static PyObject *
_wrap_gwy_app_file_load(PyObject *self, PyObject *args, PyObject *kwargs)
{
   static char *kwlist[] = {"filename", NULL};

   gchar *filename;
   GwyContainer *c;
   PyObject *object;

   if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:gwy_app_file_load", kwlist, &filename))
        return NULL;
   c = gwy_app_file_load(filename, NULL, NULL);
   object = pygobject_new((GObject *)c);
   g_object_unref(c);
   return object;
}

%%
override gwy_file_load kwargs
/**
 * gwy_file_load:
 * @filename: Filename of file to open
 * @mode: Run mode (RUN_INTERACTIVE or RUN_NONINTERACTIVE).
 *
 * Load specified file using specified mode
 *
 * Returns: A main GwyContainer of opened file
**/
static PyObject *
_wrap_gwy_file_load(PyObject *self, PyObject *args, PyObject *kwargs)
{
   static char *kwlist[] = {"filename", "mode", NULL};

   gchar *filename;
   GwyRunType mode;
   GwyContainer *c;
   PyObject *object;

   if (!PyArg_ParseTupleAndKeywords(args, kwargs,"si:gwy_file_load", kwlist, &filename, &mode))
        return NULL;
   c = gwy_file_load(filename, mode, NULL);
   object = pygobject_new((GObject *)c);
   g_object_unref(c);
   return object;
}

%%
override gwy_app_file_write kwargs
static PyObject *
_wrap_gwy_app_file_write(PyObject *self, PyObject *args, PyObject *kwargs)
{
   static char *kwlist[] = {"container", "filename", NULL};
   gchar *filename;
   PyGObject* container;

   if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:gwy_app_file_write",
               kwlist, &PyGwyContainer_Type, &container, &filename))
       return NULL;
   if (gwy_app_file_write(GWY_CONTAINER(container->obj), filename, NULL, NULL)) {
       Py_RETURN_TRUE;
   }
   else {
       Py_RETURN_FALSE;
   }


}
%%
define GwyContainer.datafields noargs
static PyObject *
_wrap_gwy_container_datafields(PyGObject *self)
{
   gint i;
   GQuark *keys;
   PyObject *py_list;
   gpointer value;

   py_list = PyList_New(0);
   if (!py_list) {
      return NULL;
   }

   keys = gwy_container_keys(GWY_CONTAINER(self->obj));
   for (i = 0 ; i < gwy_container_get_n_items(GWY_CONTAINER(self->obj)); i++)
   {
      if (gwy_container_gis_object(GWY_CONTAINER(self->obj),  keys[i], &value)
          && GWY_IS_DATA_FIELD(value))
      {
         PyList_Append(py_list, pygobject_new((GObject*)value));
      }
   }
   g_free(keys);
   return py_list;
}
%%
define GwyContainer.graph_models noargs
static PyObject *
_wrap_gwy_container_graph_models(PyGObject *self)
{
   gint i;
   GQuark *keys;
   PyObject *py_list;
   gpointer value;

   py_list = PyList_New(0);
   if (!py_list) {
      return NULL;
   }

   keys = gwy_container_keys(GWY_CONTAINER(self->obj));
   for (i = 0 ; i < gwy_container_get_n_items(GWY_CONTAINER(self->obj)); i++)
   {
      if (gwy_container_gis_object(GWY_CONTAINER(self->obj),  keys[i], &value)
          && GWY_IS_GRAPH_MODEL(value))
      {
         PyList_Append(py_list, pygobject_new((GObject*)value));
      }
   }
   g_free(keys);
   return py_list;
}

%%
define GwyDataField.number_grains noargs
/**
 * gwy_data_field_number_grains:
 *
 * Create a tuple of integer grain numbers in the data field representing a
 * mask.
 *
 * Returns: tuple of grain numbers for each piel
 **/
static PyObject *
_wrap_gwy_data_field_number_grains(PyGObject *self)
{
   gint *grains;
   guint len, xres, yres, i;
   PyObject *tuple;

   xres = gwy_data_field_get_xres(GWY_DATA_FIELD(self->obj));
   yres = gwy_data_field_get_yres(GWY_DATA_FIELD(self->obj));
   // Get size of data field
   len = xres * yres;
   // Create tuple by size of data field
   tuple = PyTuple_New(len);

   grains = g_new0(gint, len);
   gwy_data_field_number_grains(GWY_DATA_FIELD(self->obj), grains);
   // fill tuple with data field values
   for (i = 0; i < len; i++)
      PyTuple_SetItem(tuple, i, PyInt_FromLong(grains[i]));
   g_free(grains);

   return tuple;
}

%%
define GwyDataField.grains_get_values kwargs
/**
 * gwy_data_field_grains_get_values:
 * @grains: Numbered grains as obtained using gwy.DataField.number_grains()
 * @quantity: Grain quantity.
 *
 * Obtains values of one grain quantity for all grains.
 *
 * The zeroth value corresponds to the empty space between grains and isn't
 * meaningful in general.
 *
 * Returns: tuple of values of the grain quantity
 **/
static PyObject*
_wrap_gwy_data_field_grains_get_values(PyGObject *self, PyObject *args, PyObject *kwargs)
{
   static char *kwlist[] = {"grains", "quantity", NULL};

   PyObject *graintuple, *valuetuple;
   GwyGrainQuantity quantity;
   guint *grains;
   gdouble *values;
   guint xres, yres, ngrains, len, i;

   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!i:Gwy.DataField.grains_get_values", kwlist, &PyTuple_Type, &graintuple, &quantity))
        return NULL;

   xres = gwy_data_field_get_xres(GWY_DATA_FIELD(self->obj));
   yres = gwy_data_field_get_yres(GWY_DATA_FIELD(self->obj));
   len = xres * yres;
   if (PyTuple_GET_SIZE(graintuple) != len) {
        PyErr_SetString(PyExc_ValueError, "Grain number tuple length does not match the datafield size.");
        return NULL;
   }

   grains = g_new(gint, len);
   ngrains = 0;
   for (i = 0; i < len; i++) {
       PyObject *item = PyTuple_GET_ITEM(graintuple, i);
       if (!PyInt_Check(item)) {
           PyErr_SetString(PyExc_TypeError, "Grain number is not an integer.");
           g_free(grains);
           return NULL;
       }
       grains[i] = PyInt_AS_LONG(item);
       if (grains[i] > ngrains)
           ngrains = grains[i];
   }

   values = g_new(gdouble, ngrains+1);
   gwy_data_field_grains_get_values(GWY_DATA_FIELD(self->obj),
                                    values, ngrains, grains, quantity);
   g_free(grains);

   valuetuple = PyTuple_New(ngrains+1);
   for (i = 0; i <= ngrains; i++)
      PyTuple_SetItem(valuetuple, i, PyFloat_FromDouble(values[i]));
   g_free(values);

   return valuetuple;
}


// TODO: use G_OBJECT_TYPE_NAME instead of string values in set_object_by_name
/* vim: set ft=c cin et ts=4 sw=4 cino=>1s syntax=c,e0,n0,f0,{0,}0,^0,\:1s,=0,g1s,h0,t0,+1s,c3,(0,u0 : */
