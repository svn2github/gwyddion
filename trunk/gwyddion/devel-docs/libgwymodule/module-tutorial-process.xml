<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="gwymodule-tutorial-process" revision="@(#) $Id$">
  <refmeta>
    <refentrytitle>Data Processing Modules</refentrytitle>
    <manvolnum>3</manvolnum>
    <refmiscinfo>Gwyddion</refmiscinfo>
  </refmeta>

  <refnamediv>
    <refname>Data Processing Modules</refname>
    <refpurpose>
      More about data processing modules
    </refpurpose>
  </refnamediv>

  <refsect1>
    <title>Run Modes</title>
    <para>
      Now we declare the
      <link linkend="GwyRunType">run modes</link> our module supports.
    </para>
    <informalexample><programlisting><![CDATA[
#define INVERT_VALUE_RUN_MODES \
    (GWY_RUN_NONINTERACTIVE | GWY_RUN_WITH_DEFAULTS)
]]></programlisting></informalexample>
    <para>
      This is just a convenience macro, so we don't have to type them
      several times manually.
    </para>
    <para>
      There are four <link linkend="GwyRunType">run modes</link> total,
      though <literal>GWY_RUN_MODAL</literal> and
      <literal>GWY_RUN_INTERACTIVE</literal> are useful only for modules
      with a graphical user interface.
      <literal>GWY_RUN_NONINTERACTIVE</literal> is the right
      run mode for a noninteractive module like our example.
      <literal>GWY_RUN_WITH_DEFAULT</literal> is currently
      unused in <application>Gwyddion</application>, but it's a good idea (and easy) to support it too.
    </para>
  </refsect1>

  <refsect1>
    <title>Module Feature Registration</title>
    <para>
      The module registration function is called in the second registration
      stage and is responsible for registering particular module functions.
      Our module registeres only a one function,
      <literal>my_invert_value</literal>.
    </para>
    <para>
      Each function type has its own registration function, our function
      is a data processing one, so it's registered with
      <link linkend="gwy-process-func-register">gwy_process_func_register()</link>.
      File loading and/or saving functions are registered with
      <link linkend="gwy-file-func-register">gwy_file_func_register()</link>,
      etc. (at the time of writing this there exist four module function
      types).
    </para>
    <para>
      The registration itself is carried out by filling a function info
      structure and calling <function>gwy_*_func_register()</function> with
      the info.  Note the function info has to be persistent (static), because
      <application>Gwyddion</application> doesn't make a copy of it.  It must not be freed or changed
      after the registration.
    </para>
    <informalexample><programlisting><![CDATA[
static gboolean
module_register(const gchar *name)
{
    static GwyProcessFuncInfo my_invert_value_func_info = {
        "my_invert_value",
        "/_Test/My _Invert Value",
        (GwyProcessFunc)&my_invert_value,
        INVERT_VALUE_RUN_MODES,
        0,
    };

    gwy_process_func_register(name, &my_invert_value_func_info);

    return TRUE;
}
]]></programlisting></informalexample>
   <para>
     The registration function should always return <literal>TRUE</literal>.
     Returning <literal>FALSE</literal> means the registration failed, and
     <application>Gwyddion</application> then tries to unregister all its already registered functions
     and unload the module.  Normally there is hardly any reason why the
     registration could fail.
   </para>
   <para>
     The <parameter>name</parameter> argument has to be passed as the first
     argument of all function registration calls
     (<link linkend="gwy-process-func-register">gwy_process_func_register()</link>
     here).
     Now it is identical to module name specified in module info, but
     don't count on it.
   </para>
   <para>
     Each function type has a different function info structure, though some
     fields are present in all of them.  Data processing function info
     <link linkend="GwyProcessFuncInfo">GwyProcessFuncInfo</link> consits
     of function name (again, this has to be an unique identifier, among
     the functions of the same type), path where it should be placed into
     the Data Process menu, a pointer to the function itself
     (<function>my_invert_value</function>), and run modes it supports (we
     cleverly defined the <literal>INVERT_VALUE_RUN_MODES</literal> macro
     for them).
   </para>
  </refsect1>

  <refsect1>
    <title>Masks and Presentations</title>
    <para>
      To highlight some areas in the data (like the grain modules do) you may
      want to use a mask.  Masks are data fields too, differing only
      by a few things from the ordinary ones.  They live at
      <literal>"/0/mask"</literal> instead of <literal>"/0/data"</literal>
      in the container, they may not be present there, and their units are
      irrelevant – the value range is always from 0 to 1,
      0 being fully transparent and 1 the mask color set by user (may not be
      fully opaque).  To create a mask, just create a new data field and
      put it to the container with key <literal>"/0/mask"</literal>.  When
      a mask is already present there, it is more efficient to reuse it.
    </para>
    <para>
      You may also want to conceal the true nature of the data and make
      gwyddion to display them in a funny way, but without actually modifying
      them (like the shader module does).  This is possible by putting a
      <literal>"/0/show"</literal> data field to the container.  When
      present, it is displayed instead of the data.  It is really only useful
      for some final presentations, because it is not obviously updated when
      the data changes.
    </para>
  </refsect1>
</refentry>

