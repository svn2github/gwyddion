<refentry id="gwymodule-tutorial" revision="@(#) $Id$">
  <refmeta>
    <refentrytitle>Gwyddion Module Tutorial</refentrytitle>
    <manvolnum>3</manvolnum>
    <refmiscinfo>Gwyddion</refmiscinfo>
  </refmeta>

  <refnamediv>
    <refname>Gwyddion Module Tutorial</refname>
    <refpurpose>Overview of Gwyddion module anatomy and a guide for
    creating your own modules</refpurpose>
  </refnamediv>

  <refsect1>
    <title>Overview</title>
    <para>
      Gwyddion is quite a modular application.  In fact, most of its basic
      functionallity is provided by modules.  Modules allow to easily extend
      Gwyddion without the need to recompile. Modules need to be copied
      in appropriate directories only followed by Gwyddion restart.
      Modules are then automatically detected, registered and the functions provided by modules
      are added to Gwyddion menu.
    </para>
    <para>
      There are several distinct module types:
      <itemizedlist>
        <listitem><para>
          <link linkend="gwymodule-process">data processing modules</link> – these modules
          provide functions for processing of two-dimensional data arrays (e. g. <emphasis>fast fourier transform</emphasis> module),
          or changing the graphical presentation of data (e. g. <emphasis>shading</emphasis> module). Data processing
          modules usually get data (e. g. two-dimensional field of SPM data), ask for processing options
          and do requested data processing. For more interactive use, we recommend to use <emphasis>tool module</emphasis> type.
        </para></listitem>
        <listitem><para>
          <link linkend="gwymodule-file">file loading and saving modules</link>
        </para></listitem>
        <listitem><para>
          <link linkend="gwymodule-graph">graph modules</link> – these modules are used
          to process special class of data in the apllication – graphs of one-dimensional functions
          (e. g. profiles obtained by <emphasis>Profile selection</emphasis> tool).
        </para></listitem>
        <listitem><para>
          <link linkend="gwymodule-tool">tool modules</link> – tools are modules extended
          to provide more interactive interface (namely connected with selections by mouse).
          This means ability of active recomputation of the requested parameters while creating and changing selections
          on the original data (e. g. <emphasis>read value</emphasis> tool, <emphasis>three-point leveling</emphasis> tool).
        </para></listitem>
        <listitem><para>
          <link linkend="gwymodule-layer">layer modules</link> – FIXME
        </para></listitem>
      </itemizedlist>
    </para>
    <para>
      The types above are in fact
      <emphasis>function</emphasis> types, not module types.
      One module can provide a single function or a whole
      bunch of completely unrelated functions, even of different type.
      However, it's usual to
      group functions containing considreable amount of common code to one
      module to allow its sharing, and use separate modules for unrelated
      functions.
    </para>
    <para>
      More precisely, a file (i.e., a shared/dynamically linked library)
      always corresponds to a one Gwyddion module.  A module can register
      zero or more functions (features).
    </para>
  </refsect1>
  <refsect1>
    <title>A Minimal Module</title>
    <para>
      A minimal Gwyddion data-processing module could look like this:
    </para>
    <informalexample><programlisting><![CDATA[
#include <libgwyddion/gwymacros.h>
#include <libgwymodule/gwymodule.h>
#include <libprocess/datafield.h>
#include <app/app.h>

#define INVERT_VALUE_RUN_MODES \
    (GWY_RUN_NONINTERACTIVE | GWY_RUN_WITH_DEFAULTS)

static gboolean    module_register            (const gchar *name);
static gboolean    my_invert_value            (GwyContainer *data,
                                               GwyRunType run);

static GwyModuleInfo module_info = {
    GWY_MODULE_ABI_VERSION,
    &module_register,
    "value_invert",
    "Inverts data value.",
    "J. Random Hacker <hacker.jr@example.org>",
    "1.0",
    "J. Random Hacker",
    "2004",
};

GWY_MODULE_QUERY(module_info)

static gboolean
module_register(const gchar *name)
{
    static GwyProcessFuncInfo my_invert_value_func_info = {
        "my_invert_value",
        "/_Test/_Invert Value",
        (GwyProcessFunc)&my_invert_value,
        INVERT_VALUE_RUN_MODES,
    };

    gwy_process_func_register(name, &my_invert_value_func_info);

    return TRUE;
}

static gboolean
my_invert_value(GwyContainer *data, GwyRunType run)
{
    GwyDataField *dfield;

    g_return_val_if_fail(run & INVERT_VALUE_RUN_MODES, FALSE);
    dfield = GWY_DATA_FIELD(gwy_container_get_object_by_name(data, "/0/data"));
    gwy_app_undo_checkpoint(data, "/0/data");
    gwy_data_field_invert(dfield, FALSE, FALSE, TRUE);

    return TRUE;
}
]]></programlisting></informalexample>
  <para>
    Now, we should be able to compile this code (see below),  make a dynamically linked library (*.so, *.dll, depending on
    the operating system) and put it to your Gwyddion modules directory
    (e. g. /lib/gwyddion/modules/process/, however depending on your actual installation and operating
    system). After Gwyddion starts, the module is found and menu entry <emphasis>Test/Invert Value</emphasis>
    will appear in the main menu. Clicking on this menu item will invert the actual data.
    As this is the minimal module it even does not have graphical user interface to change parameters
    of data processing. However, for its purpose – data inversion – it is sufficient.
  </para>
  <para>
    Though the above example is minimal it still constis of quite a bit of code.
    We will analyse it piece-by-piece in the following paragraphs.
  </para>
  </refsect1>
  <refsect1>
    <title>Administrative</title>
    <para>
      First of all, of course, some header files.
    </para>
    <informalexample><programlisting><![CDATA[
#include <libgwyddion/gwymacros.h>
#include <libgwymodule/gwymodule.h>
#include <libprocess/datafield.h>
#include <app/app.h>
]]></programlisting></informalexample>
    <para>
      These four are essential, for a complex modules you may need additional
      headers.
      <filename><link linkend="libgwyddion-gwymacros">gwymacros.h</link></filename>
      contains some basic macros (none of them is actually used here),
      <filename><link linkend="libgwymodule-gwymoduleloader">gwymodule.h</link></filename>
      declares functions essential for registering the module and its features,
      <filename><link linkend="GwyDataField">datafield.h</link></filename>
      declared basic <link linkend="GwyDataField">GwyDataField</link> functions
      (like value inversion we will use in the module later), and
      <filename><link linkend="libgwyapp-app">app.h</link></filename>
      declares undo/redo functions and other main application related
      stuff.
    </para>
  </refsect1>
  <refsect1>
    <title>Run Modes</title>
    <para>
      Now we declare the
      <link linkend="GwyRunType">run modes</link> our module supports.
    </para>
    <informalexample><programlisting><![CDATA[
#define INVERT_VALUE_RUN_MODES \
    (GWY_RUN_NONINTERACTIVE | GWY_RUN_WITH_DEFAULTS)
]]></programlisting></informalexample>
    <para>
      This is just a convenience macro, so we don't have to type them
      several times manually.
    </para>
    <para>
      There are four <link linkend="GwyRunType">run modes</link> total,
      though <literal>GWY_RUN_MODAL</literal> and
      <literal>GWY_RUN_INTERACTIVE</literal> are useful only for modules
      with a graphical user interface.
      <literal>GWY_RUN_NONINTERACTIVE</literal> is the right
      run mode for a noninteractive module like our example.
      <literal>GWY_RUN_WITH_DEFAULT</literal> is currently
      unused in Gwyddion, but it's a good idea (and easy) to support it too.
    </para>
  </refsect1>
  <refsect1>
    <title>Function Prototypes</title>
    <para>
      Function prototypes of our functions.
    </para>
    <informalexample><programlisting><![CDATA[
static gboolean    module_register            (const gchar *name);
static gboolean    my_invert_value            (GwyContainer *data,
                                               GwyRunType run);
]]></programlisting></informalexample>
    <para>Note <emphasis>all</emphasis>
      functions and global variables should be declared
      <literal>static</literal>, the module should export no symbol
      except <link linkend="GWY-MODULE-QUERY-CAPS">GWY_MODULE_QUERY</link>
      described below.
    </para>
  </refsect1>
  <refsect1>
    <title>The Module Info Structure</title>
    <para>
      Here the interesting part starts.  The
      <link linkend="GwyModuleInfo">GwyModuleInfo</link> structure contains
      overall information about the module, most of it is presented in
      a more-or-less human-readable form Gwyddion in the module browser.
    </para>
    <informalexample><programlisting><![CDATA[
static GwyModuleInfo module_info = {
    GWY_MODULE_ABI_VERSION,
    &module_register,
    "value_invert",
    "Inverts data value.",
    "J. Random Hacker <hacker.jr@example.org>",
    "1.0",
    "J. Random Hacker",
    "2004",
]]></programlisting></informalexample>
};
    <para>
      The first item is always
      <link linkend="GWY-MODULE-ABI-VERSION-CAPS">GWY_MODULE_ABI_VERSION</link>.
      The second one is a pointer to module registration function, by
      convention called <function>module_register</function>, it is described
      in details below.
    </para>
    <para>
      The third item (<literal>"value_invert"</literal>) is the module name.
      It will appear as Module in the browser.
      A module is uniquely identified by its name, so module name have to be
      unique, Gwyddion refuses to load more modules of the same name. Otherwise
      it is a free-form string, though by convention, it is usually kept
      the same as file name of the module.
    </para>
    <para>
      The fourth item is module description.  It will appear as Description
      in the browser.  This is a short text (up to a paragraph or two)
      informing curious humans what the module is about.
    </para>
    <para>
      The next item is the module author(s).  Under normal circumstances this
      should be a name of a person (or more people).  Including a contact
      e-mail address here it's a good idea because it will appear in the
      browser as Authors, so people don't need to look to the module sources
      to find out how to contact you.
    </para>
    <para>
      The next item is the module version, a free-form string that will
      appear as Version in the browser.  Though it is free-form, using a
      versioning scheme with alorithmically comparable versions is
      preferable.
    </para>
    <para>
      The last but one and last items are module copyright and date.
      The copyright field may be the same as authors field (except without
      the eventual e-mail address), it may be an organization, or even
      someone else than the author.
    </para>
  </refsect1>
  <refsect1>
    <title>The Module Query Function</title>
    <para>
      A Gwyddion module is loaded in two stages.  First, it is queried,
      the module responds with its module info, Gwyddion checks whether it
      looks good (e.g., whether module ABI version matches). If it is OK,
      Gwyddion continues with registration of particular module features.
    </para>
    <para>
      The query function should be always constructed using the
      <link linkend="GWY-MODULE-QUERY-CAPS">GWY_MODULE_QUERY</link> macro
      as follows (note there is <emphasis>no</emphasis> semicolon after
      the right parenthesis):
    </para>
    <informalexample><programlisting><![CDATA[
GWY_MODULE_QUERY(module_info)
]]></programlisting></informalexample>
    <para>
      The <parameter>module_info</parameter> parameter is the module info
      described above.  If you change its name for any reason, change it here
      too.
    </para>
  </refsect1>
  <refsect1>
    <title>Module Feature Registration</title>
    <para>
      The module registration function is called in the second registration
      stage and is responsible for registering particular module functions.
      Our module registeres only a one function,
      <literal>my_invert_value</literal>.
    </para>
    <para>
      Each function type has its own registration function, our function
      is a data processing one, so it's registered with
      <link linkend="gwy-process-func-register">gwy_process_func_register()</link>.
      File loading and/or saving functions are registered with
      <link linkend="gwy-file-func-register">gwy_file_func_register()</link>,
      etc. (at the time of writing this there exist four module function
      types).
    </para>
    <para>
      The registration itself is carried out by filling a function info
      structure and calling <function>gwy_*_func_register()</function> with
      the info.  Note the function info has to be persistent (static), because
      Gwyddion doesn't make a copy of it.  It must not be freed or changed
      after the registration.
    </para>
    <informalexample><programlisting><![CDATA[
static gboolean
module_register(const gchar *name)
{
    static GwyProcessFuncInfo my_invert_value_func_info = {
        "my_invert_value",
        "/_Test/My _Invert Value",
        (GwyProcessFunc)&my_invert_value,
        INVERT_VALUE_RUN_MODES,
    };

    gwy_process_func_register(name, &my_invert_value_func_info);

    return TRUE;
}
]]></programlisting></informalexample>
   <para>
     The registration function should always return <literal>TRUE</literal>.
     Returning <literal>FALSE</literal> means the registration failed, and
     Gwyddion then tries to unregister all its already registered functions
     and unload the module.  Normally there is hardly any reason why the
     registration could fail.
   </para>
   <para>
     The <parameter>name</parameter> argument has to be passed as the first
     argument of all function registration calls
     (<link linkend="gwy-process-func-register">gwy_process_func_register()</link>
     here).
     Now it is identical to module name specified in module info, but
     don't count on it.
   </para>
   <para>
     Each function type has a different function info structure, though some
     fields are present in all of them.  Data processing function info
     <link linkend="GwyProcessFuncInfo">GwyProcessFuncInfo</link> consits
     of function name (again, this has to be an unique identifier, among
     the functions of the same type), path where it should be placed into
     the Data Process menu, a pointer to the function itself
     (<function>my_invert_value</function>), and run modes it supports (we
     cleverly defined the <literal>INVERT_VALUE_RUN_MODES</literal> macro
     for them).
   </para>
  </refsect1>
  <refsect1>
    <title>Executive</title>
    <para>
      Now, let's do the actuall data processing:
    </para>
    <informalexample><programlisting><![CDATA[
static gboolean
my_invert_value(GwyContainer *data, GwyRunType run)
{
    GwyDataField *dfield;

    g_return_val_if_fail(run & INVERT_VALUE_RUN_MODES, FALSE);
    dfield = GWY_DATA_FIELD(gwy_container_get_object_by_name(data, "/0/data"));
    gwy_app_undo_checkpoint(data, "/0/data");
    gwy_data_field_invert(dfield, FALSE, FALSE, TRUE);

    return TRUE;
}
]]></programlisting></informalexample>
   <para>
     A few things can be seen here.  First, we check the run mode.  More
     sofisticated modules with GUI and their own settings can do different
     things based on the run mode, but we just check if it looks sane.
   </para>
   <para>
     Next, we get a datafield from some container.
     The <link linkend="GwyDataField">GwyDataField</link> object is the
     basic data object representing two-dimensional array of values
     (height field).
     Quite a few datafield manipulating functions already exist in
     <link linkend="libprocess">libprocess</link>, we use one of them
     (<link linkend="gwy-data-field-invert">gwy_data_field_invert()</link>)
     to perform the value inversion too.
   </para>
   <para>
     The obscure part is getting the datafield out from some container that
     was passed to our function.  Just take it as a fact the data are
     called <literal>"/0/data"</literal>, it is probably equally good name
     as anything else.  There are other strange things in the container
     but you'd rather not want to know about them.
   </para>
   <para>
     The
     <link linkend="gwy-app-undo-checkpoint">gwy_app_undo_checkpoint()</link>
     creates a point in the undo history we can return to later, call it
     just before you start modifying the data.  Its second argument is
     what is to be saved, so <literal>"/0/data"</literal> follows us here
     too.
   </para>
   <para>
     Then we finally invert the value with
     <link linkend="gwy-data-field-invert">gwy_data_field_invert()</link>
     and return <literal>TRUE</literal> since we modified the data.  If we
     didn't modify them, we would have returned <literal>FALSE</literal>.
   </para>
  </refsect1>
  <refsect1>
   <title>Beyond The Minimal Module</title>
   <refsect2>
     <title>Multiple modules, multiple function, multifunctions</title>
     <para>
       Often one wants to implement a group of closely related functions that
       could share quite a bit of code.  There are several posibilities how
       to do it.
     </para>
     <para>
       The naive approach would be to put the code of all the modules to
       a one file and share what is shareable.  But alas! there can be only
       one <link linkend="GWY-MODULE-QUERY-CAPS">GWY_MODULE_QUERY</link>,
       thus a one file can register only a one module and this approach would
       not work.
     </para>
     <para>
       So the prefered solution is to register more than function for the
       module.  This is as simple as it sounds.  One just has to define more
       <link linkend="GwyProcessFuncInfo">GwyProcessFuncInfo</link>s
       (or other func infos) and register the functions one by one in
       <symbol>module_register()</symbol>.  It is even
       possible to register functions of different kind in a one module, but
       this is not recommended.
     </para>
     <para>
       The other posibility, generally not recommended but sometimes
       useful, is to define more
       <link linkend="GwyProcessFuncInfo">GwyProcessFuncInfo</link>s
       like before, but make them all points to the same C function.
       It can then determine from its last argument (<symbol>name</symbol>)
       what function the caller thinks it is calling.
       Incidentally, this is exactly how the plugin-proxy module works.
     </para>
     <title>Settings</title>
     <para>
       The nice thing about Gwyddion module dialog boxes is that they show
       the same parameter values as when you last open them, and they remember
       the settings even acros sessions.  And you of course want this feature
       in your modules too.
     </para>
     <para>
       Saving and restoring settings usually has sense only for modules with
       a GUI, simple noninteractive modules like value invert don't have any
       settings to remember.  We will get to GUI later.
     </para>
     <para>
       There is a one <link linkend="GwyContainer">GwyContainer</link> in
       Gwyddion containing settings for all modules (and other creatures).
       The function
       <link linkend="gwy-app-settings-get">gwy_app_settings_get()</link>
       will bring it to you.  It is loaded on startup and saved
       on exit so you don't need to take care about this.
       So the only thing you have to care about is to read the settings from
       it when your module starts and store them there on exit.  OK, there
       are in fact two things you have to care about.  There are no
       limitations on who can access what in the container, so to avoid
       surprises you should use only keys startings with
       <literal>"/mod/my-module-name/"</literal>.
     </para>
   </refsect2>
   <para>
     TODO: masks, presentations, GUI.
   </para>
  </refsect1>
</refentry>

